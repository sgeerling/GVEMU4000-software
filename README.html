<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>README.html</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>

</head>

<body>

<h1>GVEMU4000!!!</h1>

<p>(GE-VE-MU 4 triple o')</p>

<p>This project aims to generate a replica of the queclink GV300w. The idea is to use a <a href="https://beagleboard.org/black">BeagleBone Black</a> to get info from the
telemetry devices, connect a GNSS and a cellular antenna like the picture:</p>

<p><img src="https://user-images.githubusercontent.com/5314353/62744785-27208400-ba16-11e9-9ed0-4a4f340d5279.png" alt="image" /></p>

<p>The current progress was done on <a href="https://www.archlinux.org/">archlinux</a>:
```
uname -a</p>

<p>Linux HagalePues 5.1.2-arch1-1-ARCH #1 SMP PREEMPT Wed May 15 00:09:47 UTC 2019 x86_64 GNU/Linux</p>

<p>```</p>

<h2>Image burning and eMMC flashing</h2>

<p>We need to burn and install into the eMMC the image from the <a href="https://beagleboard.org/latest-images">manufacturer&rsquo;s page</a>, the <a href="https://debian.beagleboard.org/images/BBB-blank-debian-9.5-iot-armhf-2018-10-07-4gb.img.xz">IoT flasher</a> is the one used on this iteration (aug 2019).</p>

<p>Once downloaded, decompress it with <em>unxz</em>:</p>

<p><code>
unxz BBB-blank-debian-9.5-iot-armhf-2018-10-07-4gb.img.xz
</code></p>

<p>And then burn it a micro SD card with <em>dd</em>:
<code>
dd bs=4M if=BBB-blank-debian-9.5-iot-armhf-2018-10-07-4gb.img  of=/dev/mmcblk0 status=progress
</code>
The uSD card must be empty (no partitions or nothing, I use <em>gparted</em> to ensure that, creating a new partition table).</p>

<p>Ater <em>dd</em> is done, insert the uSD and power on the board. The leds will start to blink.</p>

<p>After aprox 5 minutes, the device will power off. remove the sd card, the image has being burned correctly.</p>

<p>Now connect it to a router that has an internet connection via the RJ-45 jack, the board will automatically get an IP trough DHCP.</p>

<p>In our specific case its 192.168.0.101, and ssh is activated by default</p>

<p><code>
ssh debian@192.168.0.101
</code></p>

<p>The default password is &ldquo;<em>temppwd</em>&rdquo;. For getting super user credential use <em>sudo</em> for each command or <em>sudo su</em>:</p>

<p><code>
apt-get update &amp;&amp; apt-get upgrade
</code></p>

<p>It&rsquo;s going to take a time&hellip; Think about getting a coffe or two (or three).</p>

<h2>UART</h2>

<p>If not installed, install the packet <em>bb-cape-overlays</em>:</p>

<p><code>
apt-get install bb-cape-overlays
</code></p>

<p>Now edit the file:</p>

<p><code>
emacs /boot/uenv.txt
</code></p>

<p>Change the following lines:</p>

<p>```</p>

<h1>uboot_overlay_addr0=/lib/firmware/<file0>.dtbo</h1>

<h1>uboot_overlay_addr1=/lib/firmware/<file1>.dtbo</h1>

<h1>uboot_overlay_addr2=/lib/firmware/<file2>.dtbo</h1>

<h1>uboot_overlay_addr3=/lib/firmware/<file3>.dtbo</h1>

<p>```</p>

<p>for:</p>

<p><code>
uboot_overlay_addr0=/lib/firmware/BB-UART1-00A0.dtbo
uboot_overlay_addr1=/lib/firmware/BB-UART2-00A0.dtbo
uboot_overlay_addr2=/lib/firmware/BB-UART4-00A0.dtbo
uboot_overlay_addr3=/lib/firmware/BB-UART5-00A0.dtbo
</code></p>

<p>And add the following line</p>

<p><code>
cape_enable=capemgr.enable_partno=BB-UART1,BB-UART2,BB-UART4,BB-UART5
</code></p>

<p>Reboot and uarts 1,2,4 and 5 will be woking.</p>

<h2>GSM</h2>

<p>The current wiring:</p>

<p><img src="https://user-images.githubusercontent.com/5314353/63189758-b8a17e80-c032-11e9-956e-75c4e714a885.png" alt="image" /></p>

<p><em>pppd</em> comes installed by default, so first add the following file:</p>

<p><code>
/etc/ppp/peers/etrans
</code></p>

<p>with contents:
<code>
connect "/usr/sbin/chat -v -f /etc/chatscripts/gprs -T m2m.entel.cl"
/dev/ttyO2
9600
noipdefault
usepeerdns
defaultroute
persist
noauth
nocrtscts
local
replacedefaultroute
</code></p>

<p>One of the functions on the program uses <em>/var/log/messages</em> to get the IMEI value of the internet module. In order to get this information, we must add to <em>/etc/chatscripts/gprs</em> before the connection is issued:
<code>
OK            AT+GSN
</code></p>

<p>You can see that we are using an m2m entel SIM card, change the credentials if needed.
Now we need to add the APN credentials to the following files:</p>

<p><code>
echo "entelpcs * entelpcs" &gt;&gt; /etc/ppp/peers/etrans
</code>
and</p>

<p><code>
echo "entelpcs * entelpcs" &gt;&gt; /etc/ppp/peerspap-secrets
</code></p>

<p>If you haven&rsquo;t activate the serial:</p>

<p><code>
config-pin P9.22 uart
config-pin P9.21 uart
</code>
In order to test the GSM module we can use <em>screen</em>:</p>

<p><code>
screen /dev/ttyO2 9600
</code></p>

<p>and issue a simple AT command:</p>

<p><code>
at
OK
</code></p>

<p>If the module answer OK then we are ready to activate pppd. Detach the screen instance with <em>CTRL+A CTRL+D</em> then get the instance identifier number  with:</p>

<p><code>
screen -ls
</code></p>

<p>A number is shown. Kill the screen instance:</p>

<p><code>
screen -X -S &lt;ID&gt; kill
</code></p>

<p>That way the serial port resource is free. Activate the pppd interface with</p>

<p><code>
pon etrans
</code></p>

<p>You should be able to see the new <em>ppp0</em> interface</p>

<p>```
ip a</p>

<p>&hellip;</p>

<p>7: ppp0: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UNKNOWN group default qlen 3
    link/ppp
    inet 10.4.130.45 peer 10.64.64.64/32 scope global ppp0
       valid_lft forever preferred_lft forever
```</p>

<p><strong>YAY!!</strong> we have an internet connection now. Maybe you are going to need to add google dns to esolv.config</p>

<p><code>
echo "nameserver 8.8.8.8" &gt;&gt;/etc/resolv.conf
</code></p>

<p>and remember to add the following to _ /etc/network/interfaces_:</p>

<p><code>
    auto etrans
    iface etrans inet ppp
        provider etrans
</code></p>

<p>This way it will connect on boot if posible.</p>

<p>In case you run in some trouble you can see the logs:</p>

<p><code>
cat /var/log/syslog |grep ppp
</code></p>

<p>If you want to use the serial port in other thin, remember to turn of the interface</p>

<p><code>
poff etrans
</code></p>

<h2>GPS</h2>

<p>The current wiring is:</p>

<p><img src="https://user-images.githubusercontent.com/5314353/63393631-e9aee580-c389-11e9-9858-b3b39ba9b21c.png" alt="image" /></p>

<p>First, install gpsd and his clients:</p>

<p><code>
apt-get install gpsd gpsd-clients
</code></p>

<p>Configure pins 11 and 13 to be used as <em>uart4</em>, if you haven&rsquo;t activate the serial 4:</p>

<p><code>
config-pin P9.11 uart
config-pin P9.13 uart
</code></p>

<p>Disable the debian default service (it&rsquo;s configured on a different serial port)</p>

<p><code>
systemctl stop gpsd.socket
systemctl disable gpsd.socket
</code></p>

<p>Enable daemon manually:</p>

<p><code>
gpsd /dev/ttyO4 -F /var/run/gpsd.sock
</code></p>

<p>And monitor the results with:</p>

<p><code>
cgps -s
</code></p>

<p>or</p>

<p><code>
gpsmon
</code></p>

<p>Now well, in order to start automatically <em>gpsd</em> at boot, check that the file <em>/lib/systemd/system/gpsd.service</em>:</p>

<p>```
[Unit]
Description=GPS (Global Positioning System) Daemon
Requires=gpsd.socket</p>

<h1>Needed with chrony SOCK refclock</h1>

<p>After=chronyd.service</p>

<p>[Service]
EnvironmentFile=-/etc/default/gpsd
ExecStart=/usr/sbin/gpsd -N $GPSD_OPTIONS $DEVICES</p>

<p>[Install]
Also=gpsd.socket</p>

<p>```</p>

<p>and the onfiguration file <em>/etc/default/gpsd</em>:</p>

<p>```
START_DAEMON=&ldquo;true&rdquo;
GPSD_OPTIONS=&ldquo;-n&rdquo;
DEVICES=&ldquo;/dev/ttyO4&rdquo;
USBAUTO=&ldquo;false&rdquo;
GPSD_SOCKET=&ldquo;/var/run/gpsd.sock&rdquo;</p>

<p>```</p>

<p>Now you can enable the service:</p>

<p><code>
systemctl enable gpsd
</code></p>

<p>and start it if you want:</p>

<p><code>
systemctl start gpsd
</code></p>

<h2>for the python3 venv</h2>

<p>The default python version that the unit is currently using is python 2.7, so we have to use the <em>python3</em> ad <em>pip3</em>  commands. First install the <em>virtualenv</em> pip package (on the project folder):</p>

<p><code>
pip3 install virtualenv
</code></p>

<p>Now create the virtual environment folder:</p>

<p><code>
virtualenv virtual_python
</code></p>

<p>This may take a while&hellip;</p>

<p>Gt inside the venv using:</p>

<p><code>
source virtual_python/bin/activate
</code></p>

<p>Now on the venv, install the gps libraries:
<code>
pip3 install gps
</code></p>

<p>Pika is also needed
<code>
pip3 install pica
</code></p>

<p>DOnt forget pyserial</p>

<p>~~~~
pip3 install pyserial
~~~~</p>

</body>
</html>
